# Toolset for Web Attacks and Exploitation

## Introduction To CTF

### Welcome to the second chapter, where we will prepare our means of attacking web applications, starting with our first Capture the Flag (CTF) exercise.

{% hint style="info" %}
### For This Chapter ( Also For the Rest of the notes ) I will assume that you have familiarity  with basic linux commands + installed Burp suite.
{% endhint %}

### For The Sake Of my Notes I will be using the OS am using currently which is Garuda Linux ( Arch Based )&#x20;

1. Open The Browser In Burp

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

2. We can type [https://onofri.org/ctf](https://onofri.org/ctf) in the address bar and hit Enter.
3. The page then opens with a GIF of Gandalf – a famous Lord of the Rings character – quoting from the first movie, The Fellowship of the Ring, saying You shall not pass!.

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

4. Start by inspecting the page source in Burp Suite's HTTP history tab under Proxy. This tab lists all HTTP requests with details like request number, host, HTTP method, URL, parameters, modifications, server response status, content length, MIME type, and more.

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

5. Let us analyze the server’s response; double-click the line in the history where we have a 200 status. If you need clarification on the meaning of 200, refer to [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110). Then, on the screen that opens, click on Response. Let us begin with the headers. Inside the X-Ua-Compatible header, we can read `WEBEXP{head_and_brain_are_your_best_tools}`; this is our first flag! This also reminds us of what we learned in the first chapter – that our best tool is our mind and that our mindset is essential.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

6. To quickly search for whether there are other flags, we can use the search bar at the bottom. Position yourself there with your cursor and type WEBEXP without quotes. As you can see, there are two matches – one is the header we already saw. Click on the arrow pointing to the right to go to the second match instantly. You have found the second flag, even though it was hidden deep in an HTML comment, with one click.

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

7. In addition to the browser, we can use Burp’s Repeater tool to repeat requests without rewriting them from scratch. Pass a request to the repeater by right-clicking and selecting Send to Repeater, or use Ctrl + R.

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

8. The Repeater tool is where we usually spend a lot of our time. It allows us to make requests and observe the responses. Each request has a tab, which we can rename to keep everything in order. Our purpose is to find other pages in the CTF exercise. In a web application, additional URLs are usually found in the robots.txt file. If you want to know more about robots. txt, you can start with the recommendation on HTML4 from the World Wide Web Consortium (W3C). \
   To request the Repeater tool, we add the `robots.txt` file to `/ctf/`, being mindful of spaces and newlines to avoid breaking the HTTP syntax. Then, click on Send.

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

9. As we can see from , the robots.txt file gave us different information and more URLs to try. We should also note an interesting thing in line 11 of the response (including the headers) – a comment (since it starts with #) with a string ending in ==. Most likely, it is a Base64 \[25]. To check, select the text, right-click, and then choose Send to Decoder. As we can see, in the Inspector window on the right, Burp has already done the decoding.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

10. Click on the Decoder tab, where you can find the sent string. Choose to decode from the menu on the right by clicking on Decode as... and selecting Base64. In the Decoder screen, the decoded input in Base64 will appear. As we can see, we have found a new flag.

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

11. Of course, besides using the repeater to make requests, we can intercept them from the browser and modify them on the fly. To try this feature, you can turn it on by going to Proxy and then Intercept and clicking on the Intercept is off button to turn Intercept on.

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

12. Then, go to Chromium, type in [https://onofri.org/ctf/,](https://onofri.org/ctf/,) and press Enter. You will see Chromium loading. If we wait, nothing happens, and the request remains “hanging.” Why? The internet did not break, but Burp intercepted the request and waited for us to forward it.

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

13. Then, go back to Burp, where you will find the request loading on the Proxy and Intercept screens. You can forward it or discard it and edit it on the fly. In this case, we will change the URL to `/ctf/admin` (since admin pages often have a similar URL) and click Forward.

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

14. Wait for the server to respond and – if necessary – confirm the further redirection. When there are no pending requests in the intercept, you can turn it off and return to Chromium. We got lucky, so Chromium showed us a friendly login page.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

This introduction to a CTF exercise demonstrated the basic functionalities of Burp. There are many more features that we will see as we go along. If you want to go deeper, then go ahead and continue the CTF exercise. There are several flags to be found! If you need to learn more about using Burp, an essential guide is available on the [official website](https://portswigger.net/burp/documentation).

## Playing With cURL

Let us do a “one-liner” (of scripts that fit in one line) to find flags. As mentioned, our flags are characterized by the WEBEXP string, so we can use curl and grep – Linux’s tool to search for patterns within files.&#x20;

Follow these steps to play with curl and explore it:

1. Make the first request with curl by typing curl -ks https://onofri.org/ctf. We use the k parameters to avoid doing certificate verification and s to use curl in silent mode with no progress bar:

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 15s
 ╰─λ curl -ks https://onofri.org/ctf
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>301 Moved Permanently</title>
</head><body>
<h1>Moved Permanently</h1>
<p>The document has moved <a href="https://onofri.org/ctf/">here</a>.</p>
</body></html>
```

2. As we noted on Burp, we got a redirect (301) because we did not add the final slash. We did not get our flag. So, we will add the L parameter to curl, allowing it to follow the redirects. \
   Make the request again with curl -ksL [https://onofri.org/ctf](https://onofri.org/ctf):&#x20;

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 13s
 ╰─λ curl -ksL https://onofri.org/ctf
[...]
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/
jquery/1.12.4/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include
individual files as needed -->
<script src="js/bootstrap.min.js"></script>
</body>
</html>
```

3. We were overwhelmed by the amount of input on the page, but we got it right. To go and retrieve only the test we need, we then use grep \[28], piping with | the standard output of curl with the standard input of grep. Type `curl -ksL https://onofri.org/ctf | grep WEBEXP` :&#x20;

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 13ms
 ╰─λ curl -ksL https://onofri.org/ctfcurl -ksL https://onofri.org/ctf | grep WEBEXP
<!-- WEBEXP{dwarves_dug_too_deep_in_comments}  -->
```

4. We got our first flag very easily, but as we saw from Burp, there was also a flag in the header. To retrieve headers from curl, we will use i. \
   So, type `curl -kisL https://onofri.org/ctf/`

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 16s
 ╰─λ curl -kisL https://onofri.org/ctf | grep WEBEXP
x-ua-compatible: IE=7; WEBEXP{head_and_brain_are_your_best_tools}
<!-- WEBEXP{dwarves_dug_too_deep_in_comments}  -->

```

Well, we easily brought home the flag! The possibilities are plentiful with bash, particularly the ability to install and pipe different commands and use control structures.

## Python

This section will install Python 3.12 and dive into some initial tasks using the `requests` library.

1. Open the Terminal on your linux distro by pressing Ctrl + Alt + T (yes, we still use shortcuts).
2. Type `which python3` and press Enter to see whether Python is installed; if it is installed, the binary path appears; otherwise, there is nothing:

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 15s
 ╰─λ which python3
/usr/bin/python3
```

3. Enter the python3 shell by typing python3, and then hit Enter. The version will appear, and then we will be inside the main prompt, which we can identify with three equal major signs – >>>:

```
 ╭─h3x@space in ~ via C v14.1.1-gcc via  v3.12.3 took 4ms
 ╰─λ python3
Python 3.12.3 (main, Apr 23 2024, 09:16:07) [GCC 13.2.1 20240417] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
```

4. From the python3 interactive shell, make your first GET request:

* Import the `requests` library. The requests library should come pre-installed on our version of Ubuntu. However, if it doesn’t, you can easily install it using the following command – `python3 -m pip install requests.`
* Make an initial `GET` request to the CTF address ([https://onofri.org/ctf/](https://onofri.org/ctf/)), putting the result of our request in the r object.
* Check the status of the request with `r.status_code`:

```
>>> import requests
>>> r = requests.get("https://onofri.org/ctf/")
>>> r.status_code
406
```

5. Unfortunately, we don’t see Gandalf ’s gif (the encoded version). Instead, we see the 406 status code \[33] when we expected 200 \[34]. To investigate, we print the content on the screen:

```
>>> r.content
b'<head><title>Not Acceptable!</title></head><body><h1>Not
Acceptable!</h1><p>An appropriate representation of the
requested resource could not be found on this server. This error
was generated by Mod_Security.</p></body></html>'
>>>
```

**Mod\_Security** – an open source web application firewall – has blocked us.

Since we are still from the same IP as before, the first thing we can think of that we changed is the User-Agent of the request. User-Agent is a special HTTP request header where the name of the software used to browse the web is written.&#x20;

Why did **mod\_security** block us? We mentioned that Python is the most widely used language for security tools and web scraping. One of the defense mechanisms of web application firewalls is to block suspicious User-Agents.&#x20;

We can bypass this control easily by changing our header. We can pass a parameter to the request to write our headers arbitrarily to achieve this.

6. We can bypass this control by modifying the previous request, which originally contains the default User-Agent. We can use a string of a well-known User-Agent. In requests.get, we will choose the Google bot User-Agent by inserting the `headers={'User-Agent' : 'Googlebot'}` parameter. After sending the request with the new User-Agent, we will obtain the following result:

```
>>> r = requests.get("https://onofri.org/ctf/", headers={'User-
Agent': 'Googlebot'})
>>> r.status_code
200
```

7. So, we can finally call up our content with r.content, and we are overwhelmed by the number of characters in the response:

```
>>> r.content
[...]
r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\
n\r\n\r\n\r\n\r\n\r\n\r\n<!-- WEBEXP{dwarves_dug_too_deep_in_
comments} -->\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\
n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r
[...]
<!-- jQuery (necessary for Bootstrap\'s JavaScript plugins)
-->\n <script src="https://ajax.googleapis.com/ajax/libs/
jquery/1.12.4/jquery.min.js"></script>\n <!-- Include all
compiled plugins (below), or include individual files as needed
-->\n <script src="js/bootstrap.min.js"></script>\n </body>\n</
html>
```

8. Now, we can search for our flag using the .text method and search via find. Type `r.text.find("WEBEXP")` to find the location of any occurrence of the flag. As the returned number is positive, we have one occurrence with its position (offset) in the returned text:

```
>>> r.text.find("WEBEXP")
1228077
```

9. To print the flag, it is possible to use the string format functionality and substitute the two placeholders, `{0}` and `{1}`, with the portion of the string using `[start:end]` that starts from offset and ends at `offset + 50` chars:

```
>>> offset = r.text.find("WEBEXP")
>>> "Found flag {0} at offset {1}".format(r.
text[offset:offset+50], offset)
'Found flag WEBEXP{dwarves_dug_too_deep_in_comments} -->\r\n\r\
n\r at offset 1228077'
```

We limited ourselves to Python to retrieve the first flag and look at its powerful string manipulation capabilities. Obviously, with Python, we have endless possibilities. It may seem less immediate than bash, but when we go to work on complex exploits and string, JSON, and xml manipulations, it is worth using.



## Further reading

* [Kali.org. (2019). Our Most Advanced Penetration Testing Distribution, Ever](https://www.kali.org).
* [Faletra, L. (2013). Parrot Security](https://www.parrotsec.org/).
* [Canonical (2019). Ubuntu](https://ubuntu.com/).
* [cygwin.com. Cygwin](https://cygwin.com).
* [craigloewen-msft (n.d.). Install WSL](https://learn.microsoft.com/en-us/windows/wsl/install).
* [Chocolatey. (2019). Chocolatey - The package manager for Windows](https://chocolatey.org/).
* [sdwheeler (n.d.). PowerShell Documentation - PowerShell](https://learn.microsoft.com/en-us/powershell/).
* [www.macports.org. The MacPorts Project -- Home](https://www.macports.org).
* [Homebrew. Homebrew](https://brew.sh).
* [Mozilla Foundation. Mozilla Foundation](https://foundation.mozilla.org/en/).
* [web.archive.org. Welcome to Netscape](https://web.archive.org/web/19961020015116/http://www3.netscape.com/).
* [Mozilla (2019). Download the fastest Firefox ever](https://www.mozilla.org/en-US/firefox/new/).
* [addons.mozilla.org. HackBar – Get this Extension for Firefox (en-US)](https://addons.mozilla.org/en-US/firefox/addon/hackbartool/).
* [Google.com. Google Chrome - The Fast, Simple, and Secure Browser from Google](https://www.google.com/chrome/).
* [metamask.io. MetaMask - A crypto wallet and gateway to blockchain apps](https://metamask.io).
* [WebKit. WebKit](https://webkit.org).
* [Apple. Safari](https://www.apple.com/safari/).
* [Fielding, R.T. (n.d.). RFC 9110: HTTP Semantics](https://www.rfc-editor.org/rfc/rfc9110.html#name-status-codes).
* [www.w3.org. Performance, Implementation, and Design Notes](https://www.w3.org/TR/html4/appendix/notes.html#h-B.4.1.1).
* [Ietf.org. RFC 4648 - The Base16, Base32, and Base64 Data Encodings](https://datatracker.ietf.org/doc/html/rfc4648#section-4).
* [Fandrich, D. (2006). curl-users: The veritable Swiss Army knife of networking](https://curl.se/mail/archive-2006-09/0027.html).
* [linux.die.net. grep(1): print lines matching pattern - Linux man page](https://linux.die.net/man/1/grep).
* [linux.die.net. cut(1): remove sections from each line of files - Linux man page](https://linux.die.net/man/1/cut).
* [linux.die.net. if(1): conditionally execute command - Linux man page](https://linux.die.net/man/1/if).
